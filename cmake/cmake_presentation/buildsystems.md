Common Build Systems
====================
This will describe the three most common build systems (Catkin, CMake, and Make) as well as their uses.

## Definitions
These may not be perfect definitions, but they are good enough for now.
* Executable - the result of compiling a c/c++ program. 
* Library - a pre-compiled piece of software that your program relies on.
	* Static - compiled library code is included in code for final program
	* Shared - compiled library code is linked in during the execution of the program

## Make vs CMake - A Simple Example
This example is based off of a [tutorial by Bruce Maxwell](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/). I have extended it to include an example of using CMake as well.

We will use the following three files for a simple hello world program:

**main.c**
``` Cpp
#include "helloworld.h"

int main() {
	helloWorld();
	return 0;
}
```

**helloworld.c**
``` Cpp
#include <stdio.h>
#include "helloworld.h"

void helloWorld() {
	printf("Hello World!\n");
}
```

**helloworld.h**
``` Cpp
#ifndef HELLO_WORLD_H_
#define HELLO_WORLD_H_

void helloWorld();

#endif /* HELLO_WORLD_H_ */
```

These files are arranged in the following directory structure, where * is either Make or CMake. Files that are generated by the build system are not shown.
```
simple_example_*/
├── build
├── include
│   └── helloworld.h
└── src
    ├── helloworld.c
    └── main.c
```

When compiling this program, you might run:
``` bash
gcc -o build/main src/main.c src/helloworld.c -Iinclude/
```
This works fine for a program consisting of a couple of files, but quickly becomes unweildy. It requires you to recall the exact command you are using when compiling, and it recompiles all of the files, regardless of if they have been changed. Recompiling unchanged files becomes a significant waste of time on any but the the simplest projects.

### Makefiles
The developers of Unix saw the need for an automated method of compiling a program, and even better, of detecting when specific files in a program need to be recompiled. They created make, which compares the timestamps of the source files with those of the compiled object files, if the sourcefile timestamp is more recent, the object file is recompiled. 

Here's about the simplest makefile that could be used to compile our example:

**Makefile_1**
``` make
hellomake: src/main.c src/helloworld.c
	gcc -o build/main src/main.c include/helloworld.c -Iinclude/
```

To run it, place it in a file titled `Makefile` in the root of `simple_example` and type `make`. Note that the gcc line must be _tabbed_ and not indented with spaces. This makefile makes it easy to recompile the program, but it would be a lot of work to add additional files, and it is still recompiling all of the files every time one is changed. This is not a tutorial on makefiles, but just to show that there is a lot that can be done with a makefile, here is a more complete example for our simple hello world program.

**Makefile_2**
``` make
CC=gcc
IDIR=include
CFLAGS=-I$(IDIR)
SDIR=src
BDIR=build

_DEPS=helloworld.h
DEPS=$(patsubst %,$(IDIR)/%,$(_DEPS))

_OBJ = helloworld.o main.o
OBJ = $(patsubst %,$(BDIR)/%,$(_OBJ))


$(BDIR)/%.o: $(SDIR)/%.c $(DEPS)
	$(CC) -c -o $@ $< $(CFLAGS)

main: $(OBJ)
	$(CC) -o $(BDIR)/$@ $^ $(CFLAGS) 

.PHONY: clean

clean:
	rm -f $(ODIR)/*.o *~ core $(IDIR)/*~ 
```

By modifying the `_DEPS` and `_OBJ` lines, you can add additional source and include files to this project easily.
The `%.o` rule compiles each `.c` file into its own object files, which are then linked together at the end in the `main` rule. 

#### Pros and Cons of Make
| Pros 			| Cons				|
| ------------- | ----------------- |
| Comes with any unix-like operating system | Not compatible with non-unix systems |
| Recompiles only changed files | Timestamp based method is susceptible to errors, requiring a `make clean` to fix them.|
| Can handle complicated build configurations | Somewhat archaic language takes time to get used to |


### CMake
From the website: "CMake is an extensible, open-source system that manages the build process in an operating system and in a compiler-independent manner. Unlike many cross-platform systems, CMake is designed to be used in conjunction with the native build environment."
Put simply, **CMake is a program that generates makefiles (lots of them).**

Continuing our simple example, for CMake, we need to create two `CMakeLists.txt` files. One goes in the root of the project and the other in the src directory.
```
simple_example_CMake/
├── build
├── CMakeLists.txt
├── include
│   └── helloworld.h
└── src
    ├── CMakeLists.txt
    ├── helloworld.c
    └── main.c
``` 

**CMakeLists.txt**
``` CMake
cmake_minimum_required (VERSION 2.8.3)
project (Simple_Example)

include_directories("${PROJECT_SOURCE_DIR}/include")
add_subdirectory(src)
```

**src/CMakeLists.txt**
``` CMake
add_library(helloworld STATIC helloworld.c)
add_executable(main main.c)
target_link_libraries(main helloworld)
```

CMake generates a lot of files, so it is common to create a `build` directory, and to run `cmake` from within that directory. In addition, since it is really just generating native build files, you must run `make` after running `cmake.` To compile the simple example:
``` bash
$ cd build/
$ cmake ..
$ make
```
Then to run `main`:
``` bash
$ build/src/main
```

## Building programs in ROS
This assumes you are already familar with the basic structure of a catkin workspace, and how to build a set of ros packages.

### Catkin
<!--![](https://en.wikipedia.org/wiki/Catkin#/media/File:Willow_catkin_2_aka.jpg "Catkins on a willow")-->
![](https://commons.wikimedia.org/wiki/File:Willow_catkin_2_aka.jpg#/media/File:Willow_catkin_2_aka.jpg "Catkins on a willow")
catkin is essentially just a wrapper for CMake that does some ros-specifiic things before calling cmake.

When you run `catkin_make` in an empty catkin workspace (as in the ROS tutorials, we'll generically call it `~/catkin_ws`), here is what is actually happening [ref](http://wiki.ros.org/catkin/commands/catkin_make)

``` bash
$ cd ~/catkin_ws
$ cd src
$ catkin_init_workspace
$ cd ..
$ mkdir build
$ cd build
$ cmake ../src -DCMAKE_INSTALL_PREFIX=../install -DCATKIN_DEVEL_PREFIX=../devel
$ make
```
The `catkin_init_workspace` command creates the top level CMakelists.txt as a symlink to a generic one found in the ros installation. Note that at the end, `cmake` is invoked on the `src` directory, and then `make` is called from within `build`.

### CMake
There are countless resources on CMake online. To give a good general overview of using CMake with ROS, we will use the `CMakeLists.txt` file from [roscopter](http://github.com/byu-magicc/roscopter/). 

## Improving the build experience
### CCache
make (and thus cmake) uses file timestamps to determine when it needs to recompile a file. There are times when files have not changed, but the timestamp has (such as on a git checkout). Additionally, on a `make clean; make` many of the built files will not change, but on a large project you will wait a long time for them to rebuild. Finally, if you are working on multiple copies of the same project (such as rosflight in roscopter and rosplane), you might be recompiling much of the same code. 

ccmake solves this by hashing the source file and compiler arguments and storing the compiled object files in a cache. I reduced the time it took for a clean recompile of roscoptor from ~50 sec to ~20 sec, including the time cmake spends regenerating files. 

#### Installing
[](https://github.com/ccache/ccache/blob/master/doc/INSTALL-from-release-archive.md)
ccache forms an "invisible" layer on top of the regular compiler. Create symbolic links to ccache as they describe in their instructions. Catkin automatically sets CMake to use `/usr/bin/c++` so, you need to link that one too.


### Ninja
[Ninja](https://ninja-build.org/) is intended to speed up incremental builds. CMake (and thus Catkin) has built in support for generating ninja buildfiles. To run `catkin_make` with ninja, just pass the `--use-ninja` flag.

# References
* [ROS official justification for Catkin](http://wiki.ros.org/catkin/conceptual_overview)
* [catkin\_make command description page](http://wiki.ros.org/catkin/commands/catkin_make)
* [Catkin CMakeLists.txt explanation](http://wiki.ros.org/catkin/CMakeLists.txt)
* [Catkin workspaces explanation](http://wiki.ros.org/catkin/workspaces)
* [Makefile tutorial by Bruce Maxwell](http://www.cs.colby.edu/maxwell/courses/tutorials/maketutor/) 
* [CMake Cookbook (Free from BYU Library)](https://learning.oreilly.com/library/view/cmake-cookbook/9781788470711/?ar)
	* [Example Code git repo](https://github.com/PacktPublishing/CMake-Cookbook)
* [ccache website](https://ccache.dev/)

